[toc]
# null && undefined
相同点：if语句中转false；null == undefined
不同点：null表示空的对象，转为数值时为0；undefined表示此处无定义的原始值，转为数值时为NaN

返回undefined：
1. 变量声明但未赋值
2. 对象未赋值的属性；数组未初始化的元素或越界访问
3. 调用函数时未提供参数，该参数为undefined
4. 函数没有返回值时，返回undefined

# 函数
函数只是一个可以执行的值。可以把函数赋值给变量和对象的属性、当作参数传入其它函数、作为函数的结果返回。

## 声明方法
```javascript
//function命令，存在变量提升
function print(){}

//函数表达式，不存在变量提升
var print = function(){};//将匿名函数赋值给变量
var print = function x(){};//该函数名仅在函数体内部有效
var print = new function() {};//这是一个匿名的用户自定义【对象】，在大括号中会构建一个变量作用域，this将指代这个作用域本身
var print = new Function('...');//使用系统内置函数对象来构建一个函数，函数体以字符串形式给出
var print = Function('...');//效果同上
```
若同一个函数被多次声明，则后面的声明将覆盖前面的声明
> 不论全局作用域或是函数作用域内部都存在变量提升现象：var声明的变量不管在什么位置，变量声明都会被提升到函数体的头部
> javascript引擎将函数名视同变量名，采用function命令声明函数时，整个函数将被提升到代码头部。
> 若采用function命令和var赋值语句声明同一个函数，最后会采用var赋值语句的定义。若采用function命令和var声明同一个变量，最后会采用function语句的定义。

## 函数属性及作用域
`.name`属性：获取参数函数的名字
`.length`属性：返回函数预期传入的参数个数
`.toString`属性：返回函数源码字符串，包括函数名及注释

函数作用域是声明时所在的作用域，在函数作用域内声明的变量在函数外无法访问。

## 函数参数
1. 函数运行时不论提供几个参数都不会报错，省略参数的值就变为undefined
2. 若函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递。即，在函数内部修改参数，将会影响到原始值。但在函数内部替换掉整个参数不会影响到原始值。（重新赋值相当指向另一个地址，此时原地址内容没有发生改变，参数仍为原来的值，因为不能改变传入的参数地址）若函数参数是原始类型的值（数值、字符串、布尔值），传递方式是传值传递。
3. 同名参数取最后出现的那个值
4. 调用函数时令形参赋值，该值是形参默认值

### 2.4arguments对象
类数组对象，包含函数运行时的所有参数，访问如`arguments[0]`，仅在函数体内部可以使用。
正常模式下，arguments对象可以在运行时修改；严格模式下（`use strict;`），arguments对象与函数参数不具有联动关系，内存相互独立。

常用应用场景：未知参数的参数调用	

相关属性：
`.length`属性：用于判断函数调用时携带参数个数；
`.callee`属性：返回对应的原函数（严格模式禁用）

## 闭包
链式作用域结构（chain scope）导致在函数作用域外部无法访问函数内部声明变量。简单理解成“定义在一个函数内部的函数”，最大的特点是可以【记住诞生的环境】并且【让这些变量始终保存在内存中】。因此可以看作是函数内部作用域的一个接口。
```javascript
function f1(){
	var n = 999;
	function f2(){//闭包
		console.log(n);
	}
	return f2;
}
var result = f1();
result();//999
```

## 立即调用的函数表达式IIFE
通常只对匿名函数使用IIFE，避免污染全局变量且利于封装外部无法读取的私有变量。
```javascript
var i = function(){return 10;}();
(function(){return 10;}());
```

## this
1. 作为直接调用的函数，指向`window`
2. 作为事件处理函数，指向关联dom
3. 作为对象内方法，指向对象本身
4. 作为构造函数、被new运算符调用的函数，指向构造函数返回的对象
5. 作为`Function.prototype.call/apply`调用的函数，指向指定的对象

