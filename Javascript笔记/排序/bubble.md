# 冒泡排序 Bubble sort

## 算法步骤与思想

遍历数组中所有相邻的两个元素，若当前两个元素的顺序与期望顺序不符就交换。经过一次遍历之后，期望顺序的最后一个元素已确定，再次对数组进行遍历时，遍历范围可减小。重复上述步骤，直到没有元素需要比较。

## 衡量指标

最快：已经是正序

最慢：已经是反序

时间复杂度：平均`O(n^2)`，最佳`O(n^2)`，最差`O(n^2)`

空间复杂度：平均`O(1)`，最佳`O(0)`，最差`O(n)`

稳定性：稳定

## 小记

排序算法中的abandon。初学冒泡总是关注被“沉底”的元素，对算法命名怀有疑惑，进而总是死记算法却总是忘记。冒泡算法的关注点是，越小的元素经过交换慢慢浮到数列顶端，过程是一个元素慢慢上浮的过程，而不是找一个向下沉，再找一个向下沉的过程。

冒泡排序中双层循环，最外层可以理解为已经确定的数组元素个数。因第一次遍历全部数组后找到了比较小的元素上浮，只剩下最大的一个已经沉底，所以此时已经确定了1个元素，i=0 -> i=1。数组总共有length个元素，需要范围逐渐缩小的遍历length-1遍就排好了序。所以i的范围是`0~length-1`。至于作为实际遍历数组的下标j，只要保证j+1不越界即可。所以`j+1 < length-i`。

总的来说，冒泡排序需要记住是一个不断扔东西的过程，每次总与相邻元素比较，可以看做两个数组元素指针并排同时向后移动。

```js
Array.prototype.bubbleSort = function() {
    for(let i = 0; i < this.length - 1; ++i) {// 已确定的元素个数
        for(let j = 0; j + 1< this.length - i; ++j) {// 正在遍历的元素下标，保证j+1不越界
            if(this[j] > this[j + 1]) {
                let tmp = this[j];
                this[j] = this[j + 1];
                this[j + 1] = tmp;
            }
        }
    }
};
```

