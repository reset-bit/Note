[toc]

# 数据库

## 基本SQL

```sql
-- 表
create table student (
	sno char(9) primary key,
    sname char(20) unique,
    sage smallint not null,
    ssex char(2) check(ssex in ('男', '女'))
);
alter table student add sentrance date;
drop table student restict/cascade;
-- 索引
create unique index stuname on student(sname);
drop index stuname;
-- 视图
create view is_student 
as select * from student;
-- 授权
grant select on table student to u1;
revoke update(sno) on table student from u2;

-- 插入
insert into student (xxx, xxx);
-- 修改
update student set sage=22 where sno='1';
-- 删除
delete from student where sno='2';

-- 重置数据库
truncate 'table_name';
```

## 数据库完整性

1. 实体完整性

   > 1. 检查主码值是否唯一，如果不唯一则拒绝插入或修改
   > 2. 检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改

2. 参照完整性

   > 1. 被参照表（student）删除元组、修改主码值，拒绝、级联删除、设为空值；
   > 2. 参照表（sc）插入元组、修改外码值，（使得在被参照表中找不到元组，使sno属性与之相等）拒绝

3. 用户自定义完整性

   > 列值是否为空、是否唯一、是否满足一个条件表达式等

## 范式

第一范式：每个分量必须是一个不可分的数据项

第二范式：在第一范式的基础上，消除非主属性对码的部分依赖（多个列组成主码，当列的子集也可做主码，则不满足第二范式）

第三范式：在第二范式的基础上，消除传递依赖（不存在码X/Y，非主属性Z，使得X->Y，Y->Z）

BC范式：在第三范式的基础上，每一个决定因素都包含候选码

第四范式：在BC范式的基础上，消除非平凡多值依赖

## 数据库设计

1. 需求分析
2. 概念结构设计
3. 逻辑结构设计
4. 物理结构设计
5. 数据库实施
6. 数据库运行和维护

## 数据库恢复技术

事务：用户定义的一个操作序列，这些操作要么全做要么全不做。

> ACID：原子性（要么全做，要么全不做）、一致性（数据库只包含成功事务提交的结果）、隔离性（并发事务互不干扰）、持续性（事务对数据库数据的改变是永久性的）

故障种类：

1. 事物内部故障：强行回滚`rollback`
2. 系统故障：如断电，撤销未完成事务，重做`redo`已提交事务
3. 介质故障：保存副本
4. 计算机病毒

## 数据库并发控制

并发操作可能带来的数据不一致问题：丢失修改（修改覆盖）、不可重复读（读取记录不一致）、读取脏数据（读取记录与真实记录不一致）

### 封锁

在事务T对某个数据对象操作之前，先向系统发出请求，对其加锁。

排它锁/写锁/X锁：加锁后，其他任何事务都不能对A加任何类型的锁

共享锁/读锁/S锁：加锁后，其他事务可以读A但不能修改A

#### 封锁协议

一级封锁协议：事务在修改R之前先加X锁，直到事务结束才释放

二级封锁协议：事务在读取R之前先加S锁，读取结束后释放S锁

三级封锁协议：事务在读取R之前先加S锁，直到事务结束才释放

### 活锁和死锁

活锁：T1封锁R，T2、T3、T4...请求封锁R，T1解封之后批准T3、T4...则T2活锁

> 先来先服务

死锁：T1封锁数据R1，T2封锁数据R2。T1等待R2，T2等待R1。

> 1. 一次封锁法：一次将要使用的数据全部加锁
> 2. 顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁

### 两段锁

所有事务必须分两个阶段对数据项加锁和解锁。在释放一个封锁之后，事务不再申请和获得其他封锁。

扩展阶段：获得封锁；收缩阶段：释放封锁。

### 意向锁

对任一节点加锁时，必须先对它的上层节点加意向锁。上锁需相容，以强锁代替弱锁。

IS锁：后裔结点拟加S锁

IX锁：后裔结点拟加X锁

SIX锁：S+IX锁